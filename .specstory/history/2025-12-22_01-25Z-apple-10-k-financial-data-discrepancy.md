<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 50fb3964-f5e0-4ed1-b7af-c156d8ac5b12 (2025-12-22 01:25Z) -->

# Apple 10-K financial data discrepancy (2025-12-22 01:25Z)

_**User (2025-12-22 01:02Z)**_

The file that is produced by the @SEC Financials Tool.exe for Apple doesn't match the values that are shown when I view the Annual 10-K on the SEC's website

---

_**Agent (model default, mode Agent)**_



---

Reviewing the tool's code and the Apple output to identify the discrepancy.


---

File seems to be binary and cannot be opened as text

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How does the tool extract financial data from SEC 10-K filings?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L78 |
| `sec_financials_tool.py` | L24-134 |
| `sec_financials_tool.py` | L242-328 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L331-459 |
| `USER_INSTRUCTIONS.md` | L59 |
| `sec_financials_tool.py` | L150-239 |
| `sec_financials_tool.py` | L242-367 |
| `example_usage.py` | L39 |
| `USER_INSTRUCTIONS.md` | L54-115 |
| `README.md` | L77-142 |
| `sec_financials_gui.py` | L11-192 |
| `sec_financials_tool.py` | L150-260 |

</details>
</tool-use>

---



---

_**User (2025-12-22 01:28Z)**_

Continue

---

_**Agent (model default, mode Ask)**_



---

Investigating the discrepancy. Checking how the tool selects periods and maps financial data.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How does the tool select which fiscal year periods to extract from SEC filings?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L78 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L24-134 |
| `sec_financials_tool.py` | L331-459 |
| `USER_INSTRUCTIONS.md` | L59 |
| `sec_financials_tool.py` | L242-328 |
| `sec_financials_gui.py` | L11-192 |
| `README.md` | L77-142 |
| `sec_financials_tool.py` | L137-161 |
| `sec_financials_tool.py` | L150-239 |
| `example_usage.py` | L39 |
| `sec_financials_tool.py` | L242-367 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are date columns selected and which period values are extracted from financial statements?" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-134 |
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L137-161 |
| `sec_financials_tool.py` | L150-239 |
| `sec_financials_tool.py` | L78 |
| `sec_financials_tool.py` | L150-260 |
| `sec_financials_tool.py` | L242-328 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L242-367 |
| `sec_financials_tool.py` | L331-459 |
| `USER_INSTRUCTIONS.md` | L59 |
| `sec_financials_gui.py` | L11-192 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "column_index|_get_value_from_row|date.*column" in "sec_financials_tool.py" • 12 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `sec_financials_tool.py` | `# Extract relevant columns: label and date columns` | L109 |
| `sec_financials_tool.py` | `# Find date columns (columns that look like dates: YYYY-MM-DD format)` | L114 |
| `sec_financials_tool.py` | `# Row 12: Fiscal Year End dates (columns B-F for historical years)` | L490 |
| `sec_financials_tool.py` | `# Populate fiscal year end date in column B (most recent year)` | L507 |
| `sec_financials_tool.py` | `def _get_value_from_row(row, column_index=0):` | L542 |
| `sec_financials_tool.py` | `column_index: Index of the numeric column to extract (0 = first date column, 1 = second, etc.)` | L548 |
| `sec_financials_tool.py` | `col_name = valid_numeric_cols[column_index] if column_index < len(valid_numeric_cols) else valid_numeric_cols[0]` | L574 |
| `sec_financials_tool.py` | `# Get the value from the first date column (most recent year)` | L622 |
| `sec_financials_tool.py` | `value = _get_value_from_row(matching_row, column_index=0)` | L623 |
| `sec_financials_tool.py` | `value = _get_value_from_row(matching_row, column_index=0)` | L678 |
| `sec_financials_tool.py` | `# Convert numeric columns (date columns) to millions` | L851 |
| `sec_financials_tool.py` | `# Check if column is numeric or looks like a date column (YYYY-MM-DD format)` | L856 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---



---

Reviewing how values are extracted from the financial statements:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are multiple date columns sorted or ordered when extracting financial statement values?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-134 |
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L150-239 |
| `sec_financials_tool.py` | L78 |
| `sec_financials_tool.py` | L150-260 |
| `sec_financials_tool.py` | L137-161 |
| `sec_financials_tool.py` | L242-328 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L242-367 |
| `USER_INSTRUCTIONS.md` | L54-115 |
| `USER_INSTRUCTIONS.md` | L59 |
| `sec_financials_tool.py` | L331-459 |
| `sec_financials_gui.py` | L11-192 |

</details>
</tool-use>

---



---

The issue is that the tool doesn't select the correct date column from the financial statements. It always uses the first date column found (`column_index=0`), which may not be the current fiscal year end.

Problems:
1. Date columns aren't sorted chronologically — the code finds date columns but doesn't sort them.
2. Always uses the first column — `_get_value_from_row()` uses `column_index=0`, which may be a prior year or an interim period.
3. No validation — it doesn't verify the selected column matches the filing's fiscal year end.

Here's the fix:

```python:sec_financials_tool.py
def format_financial_dataframe(stmt) -> pd.DataFrame:
    """
    Format financial statement to DataFrame and match Excel structure.
    Handles both Statement objects and DataFrames.
    Extracts the most relevant columns (label and date values).
    """
    if stmt is None:
        return pd.DataFrame()
    
    # Convert Statement object to DataFrame if needed
    if not isinstance(stmt, pd.DataFrame):
        if hasattr(stmt, 'to_dataframe'):
            df = stmt.to_dataframe()
        else:
            return pd.DataFrame()
    else:
        df = stmt
    
    if df.empty:
        return pd.DataFrame()
    
    # Filter out abstract/metadata rows (rows where abstract is True or label is missing)
    if 'abstract' in df.columns:
        df = df[df['abstract'] != True]
    if 'label' in df.columns:
        df = df[df['label'].notna()]
    
    # Extract relevant columns: label and date columns
    relevant_cols = []
    if 'label' in df.columns:
        relevant_cols.append('label')
    
    # Find date columns (columns that look like dates: YYYY-MM-DD format)
    import re
    from datetime import datetime
    date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
    date_cols = []
    for col in df.columns:
        if date_pattern.match(str(col)) or (isinstance(col, str) and col.startswith('20')):
            date_cols.append(col)
    
    # Sort date columns chronologically (most recent first)
    # This ensures we select the current fiscal year, not a prior year
    def parse_date_col(col_name):
        """Extract date from column name for sorting."""
        try:
            # Try to parse as YYYY-MM-DD
            if date_pattern.match(str(col_name)):
                return datetime.strptime(str(col_name), '%Y-%m-%d')
            # Try to extract date from other formats
            elif isinstance(col_name, str) and len(col_name) >= 10:
                return datetime.strptime(str(col_name)[:10], '%Y-%m-%d')
        except:
            pass
        # Fallback: return a very old date so it sorts last
        return datetime(1900, 1, 1)
    
    date_cols.sort(key=parse_date_col, reverse=True)  # Most recent first
    
    # Add sorted date columns to relevant_cols
    relevant_cols.extend(date_cols)
    
    # If we found relevant columns, use them; otherwise use all columns
    if relevant_cols:
        df = df[relevant_cols].copy()
        # Rename label to Item for consistency
        if 'label' in df.columns:
            df = df.rename(columns={'label': 'Item'})
    else:
        # Fallback: reset index and use all columns
        if df.index.nlevels > 1:
            df.index = df.index.map(lambda x: ' - '.join(str(i) for i in x) if isinstance(x, tuple) else str(x))
        df = df.reset_index()
        if len(df.columns) > 0:
            df.columns.values[0] = 'Item'
    
    return df
```

Also update `_get_value_from_row()` to better handle date column selection:

```python:sec_financials_tool.py
def _get_value_from_row(row, column_index=0, fiscal_year_end_date=None):
    """
    Helper function to extract a value from a DataFrame row.
    
    Args:
        row: pandas Series (a row from a DataFrame)
        column_index: Index of the numeric column to extract (0 = first date column, 1 = second, etc.)
        fiscal_year_end_date: Optional datetime/date to match the fiscal year end column
    
    Returns:
        float or None: The numeric value, or None if not available
    """
    if row is None or row.empty:
        return None
    
    # Get all columns excluding 'Item'
    numeric_cols = [col for col in row.index if col != 'Item']
    
    # Filter to only numeric-like columns (those that can be converted to float)
    valid_numeric_cols = []
    for col in numeric_cols:
        try:
            val = row[col]
            if pd.notna(val):
                # Try to convert to float to verify it's numeric
                float(val)
                valid_numeric_cols.append(col)
        except (ValueError, TypeError):
            continue
    
    # If fiscal_year_end_date is provided, try to find matching column first
    if fiscal_year_end_date and valid_numeric_cols:
        from datetime import datetime
        import re
        date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
        
        # Try to find column that matches the fiscal year end date
        for col in valid_numeric_cols:
            try:
                if date_pattern.match(str(col)):
                    col_date = datetime.strptime(str(col), '%Y-%m-%d').date()
                    if hasattr(fiscal_year_end_date, 'date'):
                        fy_date = fiscal_year_end_date.date()
                    else:
                        fy_date = fiscal_year_end_date
                    # Check if dates match (within 30 days to handle slight variations)
                    if abs((col_date - fy_date).days) <= 30:
                        value = row[col]
                        if pd.notna(value):
                            return float(value)
            except:
                continue
    
    # Fallback to column_index approach
    if valid_numeric_cols:
        try:
            col_name = valid_numeric_cols[column_index] if column_index < len(valid_numeric_cols) else valid_numeric_cols[0]
            value = row[col_name]
            if pd.notna(value):
                return float(value)
        except (IndexError, ValueError, TypeError):
            pass
    
    return None
```

Update the mapping functions to pass the fiscal year end date:

```python:sec_financials_tool.py
def map_income_statement_to_case_data(income_df, workbook, fiscal_year_end_date=None):
    """
    Map Income Statement data to the Case Data sheet.
    
    Args:
        income_df: pandas DataFrame containing Income Statement data (from format_financial_dataframe)
        workbook: openpyxl.Workbook object containing the template
        fiscal_year_end_date: Optional date to match the correct fiscal year column
        
    Note:
        Values are converted to millions before writing to Case Data.
        Maps to rows 13-24 in Case Data sheet.
    """
    if income_df.empty or 'Case Data' not in workbook.sheetnames:
        return
    
    case_data_sheet = workbook['Case Data']
    
    # Mapping of row numbers to search terms for Income Statement items
    # Each list contains common variations of the label name
    income_statement_mapping = {
        13: ['Sales', 'Revenue', 'Net Sales', 'Total Revenue', 'Revenues'],
        14: ['Cost of Goods Sold', 'Cost of Revenue', 'Cost of Sales', 'COGS', 'Cost of products sold'],
        15: ['Research and Development', 'R&D', 'Research and development expense', 'Research & Development'],
        16: ['Selling, General and Administrative', 'SG&A', 'Selling general and administrative', 'Selling, general & administrative'],
        17: ['Depreciation', 'Amortization', 'Depreciation and Amortization', 'Depreciation & Amortization'],
        18: ['Interest Expense', 'Interest expense', 'Interest and debt expense'],
        19: ['Non-Operating Income', 'Nonoperating Income', 'Other Income', 'Non-operating income'],
        20: ['Income Tax', 'Income Taxes', 'Tax expense', 'Provision for income taxes'],
        21: ['Noncontrolling Interest', 'Non-controlling Interest', 'Noncontrolling interests'],
        22: ['Other Income', 'Other income (loss)', 'Other Income (Loss)'],
        23: ['Extraordinary Items', 'Discontinued Operations', 'Ext. Items', 'Extraordinary items'],
        24: ['Preferred Dividends', 'Preferred Stock Dividends', 'Preferred dividends']
    }
    
    # Process each row mapping
    for row_num, search_terms in income_statement_mapping.items():
        matching_row = _find_matching_row(income_df, search_terms)
        if matching_row is not None:
            # Get the value from the first date column (most recent year, now sorted)
            # Try to match fiscal year end date if provided
            value = _get_value_from_row(matching_row, column_index=0, fiscal_year_end_date=fiscal_year_end_date)
            
            if value is not None:
                # Convert to millions before writing to Case Data
                value_in_millions = format_number_to_millions(value)
                # Write to column B (most recent year)
                # Note: Some items like expenses should be negative, but SEC data typically already includes sign
                case_data_sheet.cell(row=row_num, column=2, value=value_in_millions)
```

Apply the same change to `map_balance_sheet_to_case_data()`, and update `create_case_data_sheet()` to pass the fiscal year end date:

```python:sec_financials_tool.py
def create_case_data_sheet(workbook, financials_data: dict):
    """
    Create a new Case Data sheet with proper structure and populate with SEC financial data.
    
    Args:
        workbook: openpyxl.Workbook object
        financials_data: Dictionary from get_company_financials() containing financial data
    """
    # Remove existing Case Data sheet if it exists
    if 'Case Data' in workbook.sheetnames:
        workbook.remove(workbook['Case Data'])
    
    # Create new Case Data sheet
    case_data_sheet = workbook.create_sheet('Case Data', index=0)  # Insert at beginning
    
    # ... existing row_labels code ...
    
    # Extract fiscal year end date from filing
    filing_date = financials_data.get('filing_date')
    fiscal_year_end_date = None
    if filing_date:
        # For 10-K filings, the fiscal year end is typically in the filing metadata
        # We'll use the filing date as a reference, but ideally should extract from filing
        try:
            if hasattr(filing_date, 'date'):
                fiscal_year_end_date = filing_date.date()
            else:
                fiscal_year_end_date = filing_date
        except:
            pass
    
    # ... existing metadata population code ...
    
    # Format financial statements to DataFrames
    income_df = format_financial_dataframe(financials_data.get('income_statement'))
    balance_df = format_financial_dataframe(financials_data.get('balance_sheet'))
    cash_flow_df = format_financial_dataframe(financials_data.get('cash_flow_statement'))
    
    # Map data to Case Data sheet with fiscal year end date
    if not income_df.empty:
        map_income_statement_to_case_data(income_df, workbook, fiscal_year_end_date=fiscal_year_end_date)
    
    if not balance_df.empty:
        map_balance_sheet_to_case_data(balance_df, workbook, fiscal_year_end_date=fiscal_year_end_date)
    
    if not cash_flow_df.empty:
        map_cash_flow_to_case_data(cash_flow_df, workbook)
    
    # Apply formatting
    _format_case_data_sheet(case_data_sheet)
```

Summary:
- Sort date columns chronologically (most recent first) so the first column is the current fiscal year.
- Optionally match the fiscal year end date column when available.
- This ensures the tool selects the correct period instead of a prior year or interim period.

Should I provide the complete updated functions, or do you want to test this approach first?

---

_**User (2025-12-22 01:34Z)**_

What's the best way to test that this sorting change will extract the correct data?

---

_**Agent (model default, mode Ask)**_



---

Reviewing the code to design a test that verifies the sorting selects the correct fiscal year data.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How to test or debug financial data extraction from SEC filings?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L78 |
| `sec_financials_tool.py` | L24-134 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L242-328 |
| `sec_financials_tool.py` | L331-459 |
| `USER_INSTRUCTIONS.md` | L54-115 |
| `example_usage.py` | L39 |
| `USER_INSTRUCTIONS.md` | L59 |
| `sec_financials_gui.py` | L11-192 |
| `USER_INSTRUCTIONS.md` | L111-161 |
| `README.md` | L77-142 |
| `BUILD_INSTRUCTIONS.md` | L80-151 |
| `README.md` | L140-144 |
| `QUICK_START.md` | L70 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="file_search">
<details>
            <summary>Tool use: **file_search** • Searched codebase "test" • **3** results</summary>
        
| File |
|------|
| `c:\Users\tpost\Projects\FinPilot\Examples\SEC_Tool_Test.xlsx` |
| `c:\Users\tpost\Projects\FinPilot\MANUAL_TESTING_GUIDE.md` |
| `c:\Users\tpost\Projects\FinPilot\templates\financial_analysis_template.xlsx` |

</details>
</tool-use>

---



---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: example_usage.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: MANUAL_TESTING_GUIDE.md</summary>

</details>
</tool-use>

---



---

Create a test script to verify the date column sorting fix. It will:

1. Fetch Apple's financial data
2. Show available date columns (unsorted vs sorted)
3. Extract values from each column
4. Compare before/after sorting
5. Show which column should be used

Here's a test script:

```python
#!/usr/bin/env python3
"""
Test script to verify date column sorting fixes data extraction issues.
This script compares unsorted vs sorted date column extraction for Apple.
"""

import sys
from pathlib import Path
from datetime import datetime
import pandas as pd
from edgar import Company, set_identity
import os
import re

# Add parent directory to path to import sec_financials_tool
sys.path.insert(0, str(Path(__file__).parent))

from sec_financials_tool import get_company_financials, format_financial_dataframe

def parse_date_col(col_name):
    """Extract date from column name for sorting."""
    date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
    try:
        if date_pattern.match(str(col_name)):
            return datetime.strptime(str(col_name), '%Y-%m-%d')
        elif isinstance(col_name, str) and len(col_name) >= 10:
            return datetime.strptime(str(col_name)[:10], '%Y-%m-%d')
    except:
        pass
    return datetime(1900, 1, 1)

def format_financial_dataframe_with_sorting(stmt) -> pd.DataFrame:
    """
    Version of format_financial_dataframe WITH date column sorting.
    This is the fixed version we want to test.
    """
    if stmt is None:
        return pd.DataFrame()
    
    if not isinstance(stmt, pd.DataFrame):
        if hasattr(stmt, 'to_dataframe'):
            df = stmt.to_dataframe()
        else:
            return pd.DataFrame()
    else:
        df = stmt
    
    if df.empty:
        return pd.DataFrame()
    
    if 'abstract' in df.columns:
        df = df[df['abstract'] != True]
    if 'label' in df.columns:
        df = df[df['label'].notna()]
    
    relevant_cols = []
    if 'label' in df.columns:
        relevant_cols.append('label')
    
    date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
    date_cols = []
    for col in df.columns:
        if date_pattern.match(str(col)) or (isinstance(col, str) and col.startswith('20')):
            date_cols.append(col)
    
    # SORT DATE COLUMNS (most recent first) - THIS IS THE FIX
    date_cols.sort(key=parse_date_col, reverse=True)
    
    relevant_cols.extend(date_cols)
    
    if relevant_cols:
        df = df[relevant_cols].copy()
        if 'label' in df.columns:
            df = df.rename(columns={'label': 'Item'})
    else:
        if df.index.nlevels > 1:
            df.index = df.index.map(lambda x: ' - '.join(str(i) for i in x) if isinstance(x, tuple) else str(x))
        df = df.reset_index()
        if len(df.columns) > 0:
            df.columns.values[0] = 'Item'
    
    return df

def get_value_from_row(row, column_index=0):
    """Extract value from row at specified column index."""
    if row is None or row.empty:
        return None
    
    numeric_cols = [col for col in row.index if col != 'Item']
    valid_numeric_cols = []
    for col in numeric_cols:
        try:
            val = row[col]
            if pd.notna(val):
                float(val)
                valid_numeric_cols.append(col)
        except:
            continue
    
    if valid_numeric_cols:
        try:
            col_name = valid_numeric_cols[column_index] if column_index < len(valid_numeric_cols) else valid_numeric_cols[0]
            value = row[col_name]
            if pd.notna(value):
                return float(value)
        except:
            pass
    
    return None

def find_matching_row(df, search_terms):
    """Find row matching search terms."""
    if df.empty or 'Item' not in df.columns:
        return None
    
    for term in search_terms:
        mask = df['Item'].str.contains(term, na=False, regex=False, case=False)
        if mask.any():
            return df[mask].iloc[0]
    return None

def test_date_column_extraction(ticker="AAPL", year=None):
    """
    Test date column extraction with and without sorting.
    """
    print(f"=" * 80)
    print(f"Testing Date Column Extraction for {ticker}")
    print(f"=" * 80)
    print()
    
    # Set identity for SEC API
    email = os.getenv('SEC_API_EMAIL', 'test@example.com')
    set_identity(email)
    print(f"Using SEC API email: {email}")
    print()
    
    # Fetch financial data
    print(f"Fetching financial data for {ticker}...")
    try:
        financials_data = get_company_financials(ticker, year, "10-K")
        print(f"✓ Successfully fetched data")
        print(f"  Company: {financials_data['company_name']}")
        print(f"  Filing Date: {financials_data['filing_date']}")
        print()
    except Exception as e:
        print(f"✗ Error fetching data: {e}")
        return
    
    # Test Income Statement
    print("-" * 80)
    print("INCOME STATEMENT ANALYSIS")
    print("-" * 80)
    
    income_stmt = financials_data['income_statement']
    
    # Format WITHOUT sorting (current behavior)
    df_unsorted = format_financial_dataframe(income_stmt)
    
    # Format WITH sorting (proposed fix)
    df_sorted = format_financial_dataframe_with_sorting(income_stmt)
    
    # Get date columns
    date_cols_unsorted = [col for col in df_unsorted.columns if col != 'Item']
    date_cols_sorted = [col for col in df_sorted.columns if col != 'Item']
    
    print(f"\nDate columns found: {len(date_cols_unsorted)}")
    print(f"\nUNSORTED order (current behavior):")
    for i, col in enumerate(date_cols_unsorted):
        print(f"  [{i}] {col}")
    
    print(f"\nSORTED order (proposed fix - most recent first):")
    for i, col in enumerate(date_cols_sorted):
        print(f"  [{i}] {col}")
    
    # Test key line items
    test_items = {
        'Revenue': ['Sales', 'Revenue', 'Net Sales', 'Total Revenue', 'Revenues'],
        'Cost of Goods Sold': ['Cost of Goods Sold', 'Cost of Revenue', 'Cost of Sales', 'COGS'],
        'Net Income': ['Net Income', 'Net income', 'Net earnings']
    }
    
    print(f"\n" + "=" * 80)
    print("VALUE COMPARISON (in millions)")
    print("=" * 80)
    print(f"{'Line Item':<30} {'Unsorted[0]':<20} {'Sorted[0]':<20} {'Difference':<15}")
    print("-" * 80)
    
    for item_name, search_terms in test_items.items():
        row_unsorted = find_matching_row(df_unsorted, search_terms)
        row_sorted = find_matching_row(df_sorted, search_terms)
        
        if row_unsorted is not None:
            val_unsorted = get_value_from_row(row_unsorted, 0)
            val_unsorted_millions = val_unsorted / 1_000_000 if val_unsorted else None
        else:
            val_unsorted_millions = None
        
        if row_sorted is not None:
            val_sorted = get_value_from_row(row_sorted, 0)
            val_sorted_millions = val_sorted / 1_000_000 if val_sorted else None
        else:
            val_sorted_millions = None
        
        diff = None
        if val_unsorted_millions and val_sorted_millions:
            diff = val_sorted_millions - val_unsorted_millions
        
        unsorted_str = f"${val_unsorted_millions:,.0f}M" if val_unsorted_millions else "N/A"
        sorted_str = f"${val_sorted_millions:,.0f}M" if val_sorted_millions else "N/A"
        diff_str = f"${diff:,.0f}M" if diff is not None else "N/A"
        
        print(f"{item_name:<30} {unsorted_str:<20} {sorted_str:<20} {diff_str:<15}")
    
    # Show all values for first date column (unsorted vs sorted)
    print(f"\n" + "=" * 80)
    print("DETAILED COMPARISON - First Date Column Values")
    print("=" * 80)
    
    if date_cols_unsorted and date_cols_sorted:
        first_col_unsorted = date_cols_unsorted[0]
        first_col_sorted = date_cols_sorted[0]
        
        print(f"\nUNSORTED - First column: {first_col_unsorted}")
        print(f"SORTED - First column: {first_col_sorted}")
        
        if first_col_unsorted != first_col_sorted:
            print(f"\n⚠️  WARNING: First column differs! This could cause incorrect data extraction.")
            print(f"   The tool is currently using: {first_col_unsorted}")
            print(f"   It should be using: {first_col_sorted}")
        else:
            print(f"\n✓ First column matches (no sorting needed or already correct)")
    
    # Show sample rows with all date column values
    print(f"\n" + "=" * 80)
    print("SAMPLE ROW - All Date Column Values")
    print("=" * 80)
    
    revenue_row = find_matching_row(df_sorted, ['Sales', 'Revenue', 'Net Sales', 'Total Revenue'])
    if revenue_row is not None:
        print(f"\nLine Item: {revenue_row['Item']}")
        print(f"\nAll date column values (sorted order):")
        for col in date_cols_sorted:
            val = revenue_row[col]
            if pd.notna(val):
                val_millions = float(val) / 1_000_000
                print(f"  {col}: ${val_millions:,.0f}M")
            else:
                print(f"  {col}: N/A")
    
    print(f"\n" + "=" * 80)
    print("RECOMMENDATION")
    print("=" * 80)
    
    if date_cols_unsorted != date_cols_sorted:
        print("✓ Sorting is needed - date columns are in wrong order")
        print("  The sorted version should extract the correct (most recent) fiscal year data")
    else:
        print("⚠️  Date columns are already in correct order (or only one column exists)")
        print("  Sorting may not fix the issue - investigate other causes")
    
    print()

if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='Test date column sorting for SEC financial data extraction')
    parser.add_argument('ticker', nargs='?', default='AAPL', help='Company ticker (default: AAPL)')
    parser.add_argument('--year', type=int, help='Fiscal year to test')
    
    args = parser.parse_args()
    
    test_date_column_extraction(args.ticker, args.year)
```

Save this as `test_date_column_sorting.py` in your project root. Run it:

```bash
python test_date_column_sorting.py AAPL
```

Or for a specific year:

```bash
python test_date_column_sorting.py AAPL --year 2024
```

What it shows:
1. Date columns found (unsorted vs sorted)
2. Value comparison for key line items (Revenue, COGS, Net Income)
3. Which column is used first (unsorted vs sorted)
4. Sample row with all date column values
5. Recommendation on whether sorting is needed

Additional manual verification:
1. Check the SEC website for Apple's 10-K and note the fiscal year end date (e.g., September 30, 2024).
2. Compare the sorted first column date with that fiscal year end.
3. Compare the extracted values with the SEC website values.

This will confirm whether sorting fixes the issue or if there are other problems (e.g., wrong line item matching, unit conversion issues).

---

_**User (2025-12-22 02:00Z)**_

When I ran this test, it identified the correct Net Sales number, but the @Apple-FY-2025-Financials.xlsx file that was previously produced by the data extraction feature has a different Net Sales number. Why?

---

_**Agent (model default, mode Ask)**_



---


Investigating why the Excel file shows a different Net Sales value. Checking the mapping logic and how the Excel file was generated.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: sec_financials_tool.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How does the tool match Net Sales or Revenue line items when mapping to Case Data sheet?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `sec_financials_tool.py` | L24-134 |
| `sec_financials_tool.py` | L150-239 |
| `sec_financials_tool.py` | L150-260 |
| `sec_financials_tool.py` | L24-78 |
| `sec_financials_tool.py` | L78 |
| `sec_financials_tool.py` | L242-328 |
| `sec_financials_tool.py` | L242-367 |
| `sec_financials_tool.py` | L137-161 |
| `README.md` | L80 |
| `sec_financials_tool.py` | L81-147 |
| `USER_INSTRUCTIONS.md` | L59 |
| `USER_INSTRUCTIONS.md` | L54-115 |
| `sec_financials_tool.py` | L331-459 |
| `build_gui_app.py` | L70 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "Net Sales|Revenue|Sales.*Revenue" in "sec_financials_tool.py" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `sec_financials_tool.py` | `'revenue_growth_rate': 0.15,` | L257 |
| `sec_financials_tool.py` | `13: ['Sales', 'Revenue', 'Net Sales', 'Total Revenue', 'Revenues'],` | L604 |
| `sec_financials_tool.py` | `14: ['Cost of Goods Sold', 'Cost of Revenue', 'Cost of Sales', 'COGS', 'Cost of products sold'],` | L605 |


</details>
</tool-use>

---



---


The Excel file likely differs because:
1. It was generated before the date column sorting fix, so it used the wrong fiscal year.
2. The search terms match the first item found, which may not be "Net Sales".

The mapping uses this search order:
```604:604:sec_financials_tool.py
        13: ['Sales', 'Revenue', 'Net Sales', 'Total Revenue', 'Revenues'],
```

If the income statement has both "Sales" and "Net Sales", it matches "Sales" first.

Here's a diagnostic script to check what's in the Excel file and compare it to what should be extracted:

```python
#!/usr/bin/env python3
"""
Diagnostic script to compare Excel file values with what should be extracted.
This helps identify why the Excel file has different values than expected.
"""

import sys
from pathlib import Path
from datetime import datetime
import pandas as pd
from edgar import Company, set_identity
import os
import re
from openpyxl import load_workbook

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent))

from sec_financials_tool import get_company_financials, format_financial_dataframe, _find_matching_row, _get_value_from_row

def parse_date_col(col_name):
    """Extract date from column name for sorting."""
    date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
    try:
        if date_pattern.match(str(col_name)):
            return datetime.strptime(str(col_name), '%Y-%m-%d')
        elif isinstance(col_name, str) and len(col_name) >= 10:
            return datetime.strptime(str(col_name)[:10], '%Y-%m-%d')
    except:
        pass
    return datetime(1900, 1, 1)

def format_financial_dataframe_with_sorting(stmt) -> pd.DataFrame:
    """Version WITH date column sorting."""
    if stmt is None:
        return pd.DataFrame()
    
    if not isinstance(stmt, pd.DataFrame):
        if hasattr(stmt, 'to_dataframe'):
            df = stmt.to_dataframe()
        else:
            return pd.DataFrame()
    else:
        df = stmt
    
    if df.empty:
        return pd.DataFrame()
    
    if 'abstract' in df.columns:
        df = df[df['abstract'] != True]
    if 'label' in df.columns:
        df = df[df['label'].notna()]
    
    relevant_cols = []
    if 'label' in df.columns:
        relevant_cols.append('label')
    
    date_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}$')
    date_cols = []
    for col in df.columns:
        if date_pattern.match(str(col)) or (isinstance(col, str) and col.startswith('20')):
            date_cols.append(col)
    
    # SORT DATE COLUMNS (most recent first)
    date_cols.sort(key=parse_date_col, reverse=True)
    relevant_cols.extend(date_cols)
    
    if relevant_cols:
        df = df[relevant_cols].copy()
        if 'label' in df.columns:
            df = df.rename(columns={'label': 'Item'})
    else:
        if df.index.nlevels > 1:
            df.index = df.index.map(lambda x: ' - '.join(str(i) for i in x) if isinstance(x, tuple) else str(x))
        df = df.reset_index()
        if len(df.columns) > 0:
            df.columns.values[0] = 'Item'
    
    return df

def diagnose_excel_file(excel_path, ticker="AAPL", year=None):
    """
    Diagnose what's in the Excel file vs what should be there.
    """
    print(f"=" * 80)
    print(f"Diagnosing Excel File: {excel_path}")
    print(f"=" * 80)
    print()
    
    # Load Excel file
    if not os.path.exists(excel_path):
        print(f"✗ Excel file not found: {excel_path}")
        return
    
    print(f"✓ Loading Excel file...")
    wb = load_workbook(excel_path, data_only=True)
    
    # Check if Case Data sheet exists
    if 'Case Data' not in wb.sheetnames:
        print(f"✗ 'Case Data' sheet not found in Excel file")
        print(f"  Available sheets: {', '.join(wb.sheetnames)}")
        return
    
    case_data = wb['Case Data']
    
    # Get Net Sales value from Excel (row 13, column B)
    excel_net_sales = case_data['B13'].value
    print(f"\nExcel File Values (Case Data sheet):")
    print(f"  Row 13 (Sales/Revenue): {excel_net_sales}")
    if excel_net_sales is not None:
        print(f"    In millions: ${excel_net_sales:,.0f}M")
        print(f"    Raw value: {excel_net_sales}")
    
    # Fetch fresh data from SEC
    print(f"\n" + "-" * 80)
    print("Fetching fresh data from SEC...")
    print("-" * 80)
    
    email = os.getenv('SEC_API_EMAIL', 'test@example.com')
    set_identity(email)
    
    try:
        financials_data = get_company_financials(ticker, year, "10-K")
        print(f"✓ Fetched data for {financials_data['company_name']}")
        print(f"  Filing Date: {financials_data['filing_date']}")
    except Exception as e:
        print(f"✗ Error fetching data: {e}")
        return
    
    # Format income statement (WITHOUT sorting - current behavior)
    income_df_unsorted = format_financial_dataframe(financials_data['income_statement'])
    
    # Format income statement (WITH sorting - fixed behavior)
    income_df_sorted = format_financial_dataframe_with_sorting(financials_data['income_statement'])
    
    # Get date columns
    date_cols_unsorted = [col for col in income_df_unsorted.columns if col != 'Item']
    date_cols_sorted = [col for col in income_df_sorted.columns if col != 'Item']
    
    print(f"\n" + "=" * 80)
    print("ANALYSIS: What Should Be Extracted")
    print("=" * 80)
    
    # Search terms used in the tool
    search_terms = ['Sales', 'Revenue', 'Net Sales', 'Total Revenue', 'Revenues']
    
    print(f"\nSearch terms used (in order): {search_terms}")
    print(f"\nUNSORTED date columns (current code behavior):")
    for i, col in enumerate(date_cols_unsorted):
        print(f"  [{i}] {col}")
    
    print(f"\nSORTED date columns (fixed code behavior):")
    for i, col in enumerate(date_cols_sorted):
        print(f"  [{i}] {col}")
    
    # Find what line item would be matched
    print(f"\n" + "-" * 80)
    print("Line Item Matching Analysis")
    print("-" * 80)
    
    # Check UNSORTED
    matching_row_unsorted = _find_matching_row(income_df_unsorted, search_terms)
    if matching_row_unsorted is not None:
        matched_item_unsorted = matching_row_unsorted['Item']
        value_unsorted = _get_value_from_row(matching_row_unsorted, 0)
        value_unsorted_millions = value_unsorted / 1_000_000 if value_unsorted else None
        
        print(f"\nUNSORTED (current code would match):")
        print(f"  Matched line item: '{matched_item_unsorted}'")
        print(f"  Value from first date column [{date_cols_unsorted[0] if date_cols_unsorted else 'N/A'}]:")
        if value_unsorted_millions:
            print(f"    ${value_unsorted_millions:,.0f}M (raw: {value_unsorted:,.0f})")
        else:
            print(f"    N/A")
    else:
        print(f"\nUNSORTED: No matching line item found!")
    
    # Check SORTED
    matching_row_sorted = _find_matching_row(income_df_sorted, search_terms)
    if matching_row_sorted is not None:
        matched_item_sorted = matching_row_sorted['Item']
        value_sorted = _get_value_from_row(matching_row_sorted, 0)
        value_sorted_millions = value_sorted / 1_000_000 if value_sorted else None
        
        print(f"\nSORTED (fixed code would match):")
        print(f"  Matched line item: '{matched_item_sorted}'")
        print(f"  Value from first date column [{date_cols_sorted[0] if date_cols_sorted else 'N/A'}]:")
        if value_sorted_millions:
            print(f"    ${value_sorted_millions:,.0f}M (raw: {value_sorted:,.0f})")
        else:
            print(f"    N/A")
    else:
        print(f"\nSORTED: No matching line item found!")
    
    # Compare with Excel file
    print(f"\n" + "=" * 80)
    print("COMPARISON")
    print("=" * 80)
    
    print(f"\nExcel file value: {excel_net_sales}")
    if excel_net_sales and value_unsorted_millions:
        diff_unsorted = excel_net_sales - value_unsorted_millions
        print(f"  vs UNSORTED: {diff_unsorted:,.0f}M difference")
    if excel_net_sales and value_sorted_millions:
        diff_sorted = excel_net_sales - value_sorted_millions
        print(f"  vs SORTED: {diff_sorted:,.0f}M difference")
    
    # Show all potential matches
    print(f"\n" + "-" * 80)
    print("All Potential Revenue/Sales Line Items Found:")
    print("-" * 80)
    
    for term in search_terms:
        mask = income_df_sorted['Item'].str.contains(term, na=False, regex=False, case=False)
        matches = income_df_sorted[mask]
        if not matches.empty:
            for idx, row in matches.iterrows():
                item_name = row['Item']
                val = _get_value_from_row(row, 0)
                val_millions = val / 1_000_000 if val else None
                date_col = date_cols_sorted[0] if date_cols_sorted else 'N/A'
                print(f"\n  '{item_name}'")
                print(f"    First date column [{date_col}]: ${val_millions:,.0f}M" if val_millions else f"    First date column [{date_col}]: N/A")
    
    # Diagnosis
    print(f"\n" + "=" * 80)
    print("DIAGNOSIS")
    print("=" * 80)
    
    if matching_row_unsorted is not None and matching_row_sorted is not None:
        if matched_item_unsorted != matched_item_sorted:
            print(f"⚠️  ISSUE: Different line items matched!")
            print(f"   Excel likely used: '{matched_item_unsorted}'")
            print(f"   Should use: '{matched_item_sorted}'")
        elif date_cols_unsorted[0] != date_cols_sorted[0]:
            print(f"⚠️  ISSUE: Wrong date column used!")
            print(f"   Excel likely used: {date_cols_unsorted[0]}")
            print(f"   Should use: {date_cols_sorted[0]}")
        elif excel_net_sales and abs(excel_net_sales - value_sorted_millions) > 0.01:
            print(f"⚠️  ISSUE: Value mismatch!")
            print(f"   Excel has: ${excel_net_sales:,.0f}M")
            print(f"   Should be: ${value_sorted_millions:,.0f}M")
            print(f"   Difference: ${abs(excel_net_sales - value_sorted_millions):,.0f}M")
        else:
            print(f"✓ Values match! Excel file appears correct.")
    else:
        print(f"⚠️  Could not find matching line items to compare.")

if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='Diagnose Excel file vs expected values')
    parser.add_argument('excel_path', help='Path to Excel file to diagnose')
    parser.add_argument('--ticker', default='AAPL', help='Company ticker (default: AAPL)')
    parser.add_argument('--year', type=int, help='Fiscal year')
    
    args = parser.parse_args()
    
    diagnose_excel_file(args.excel_path, args.ticker, args.year)
```

Run it like this:

```bash
python diagnose_excel_file.py "Examples/Apple-FY-2025-Financials.xlsx" AAPL
```

This script will:
1. Read the Net Sales value from the Excel file
2. Fetch fresh data from SEC
3. Show which line item was matched (unsorted vs sorted)
4. Show which date column was used
5. Compare Excel values with what should be extracted
6. List all potential revenue/sales line items found

This will show whether the issue is:
- Wrong date column (prior year instead of current year)
- Wrong line item matched (e.g., "Sales" instead of "Net Sales")
- Both

After running this, you'll know exactly why the Excel file has a different value and can confirm whether the sorting fix resolves it.

---

